// Generated by CoffeeScript 1.6.3
var EventEmitter, Git, bold, dft_options, exec, fs, mkpkg, qa, rl, util;

EventEmitter = require('events').EventEmitter;

exec = require('child_process').exec;

fs = require('fs');

rl = require('readline');

util = require('util');

Git = require('git/lib/git').Git;

qa = require('./qa');

dft_options = require('./options');

require('./set_prompt');

bold = function(text) {
  return "\x1b[1m" + text + "\x1b[22m";
};

mkpkg = function(options) {
  var k, rli, v,
    _this = this;
  if (options == null) {
    options = {};
  }
  for (k in dft_options) {
    v = dft_options[k];
    if (options[k] == null) {
      options[k] = v;
    }
  }
  EventEmitter.call(this, options);
  rli = options["interface"] = rl.createInterface(options.input, options.output, options.completer, options.terminal);
  options.input.on('keypress', function(s, key) {
    if ((key != null ? key.name : void 0) === 'escape') {
      options["interface"]._questionCallback = null;
      if (_this.questions) {
        _this.questions.disable();
      }
      return _this.help();
    } else if ((key != null ? key.name : void 0) === 'down') {
      options.index++;
      return _this.create();
    } else if ((key != null ? key.name : void 0) === 'up') {
      if (options.index) {
        options.index--;
      }
      return _this.create();
    }
  });
  this.intro = function() {
    options["interface"].write(options.intro);
    options["interface"].write('\n');
    return _this[options.action]();
  };
  this.quit = function() {
    _this.emit('quit');
    if (options.exit) {
      _this.emit('exit');
      return process.exit();
    }
  };
  this.error = function(msg, exit) {
    options["interface"].write(msg);
    if (exit === true) {
      exit = 1;
    }
    if (exit) {
      return _this.quit(exit);
    }
  };
  this.help = function() {
    options["interface"].write("\n" + options.commands + "\n");
    return options["interface"].question('', function(answer) {
      switch (answer) {
        case 'quit':
        case 'q':
          return _this.quit();
        case 'load':
        case 'l':
          return _this.load();
        case 'reset':
        case 'r':
          return _this.reset();
        case 'save':
        case 's':
          return _this.save();
        case 'view':
        case 'v':
          return _this.view();
        case 'create':
        case 'c':
        case '':
          return _this.create();
        default:
          return _this.error('Invalid command');
      }
    });
  };
  this.view = function() {
    var i, question, _i, _len, _ref, _results;
    _ref = options.questions;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      question = _ref[i];
      if (i === options.max_index) {
        break;
      }
      _results.push(options["interface"].write("" + question.name + ": " + question.value + "\n"));
    }
    return _results;
  };
  this.create = function() {
    var generate;
    if (!_this.questions) {
      _this.questions = qa(options, function(err, answers) {
        return generate(answers);
      });
    } else {
      _this.questions.ask();
    }
    return generate = function(answers) {
      var do_check, do_finish, do_git, do_gitignore, do_layout, do_makefile, do_mkdir, do_packagedotjson;
      do_check = function() {
        return fs.stat(answers.location, function(err, stat) {
          if (err) {
            return do_mkdir();
          }
          return options["interface"].question("Do you wish to overwrite the directory [" + (bold('yes')) + ",no]", function(answer) {
            switch (answer) {
              case 'yes':
              case 'y':
              case '':
                return do_git();
              default:
                return save();
            }
          });
        });
      };
      do_mkdir = function() {
        return fs.mkdir(answers.location, function(err) {
          if (err) {
            return error(err, true);
          }
          return do_git();
        });
      };
      do_git = function() {
        return fs.exists("" + answers.location + "/.git", function(exists) {
          if (exists) {
            return gitignore();
          }
          return exec("cd " + answers.location + " && git init", function(err, stdout, stderr) {
            if (err) {
              return next(err);
            }
            return do_gitignore();
          });
        });
      };
      do_gitignore = function() {
        var content;
        content = ".*\n/node_modules\n!.travis.yml\n!.gitignore";
        return fs.writeFile("" + answers.location + "/.gitignore", content, function(err) {
          if (err) {
            return next(err);
          }
          return do_layout();
        });
      };
      do_layout = function() {
        var do_lib, do_src, do_test;
        do_lib = function() {
          return fs.mkdir("" + answers.location + "/lib", function(err) {
            return fs.writeFile("" + answers.location + "/lib/index.js", "\nmodule.exports = function(callback) {\n  return process.setImmediate(function() {\n    return callback(null, 'Hello world');\n  });\n};\n", function(err) {
              if (err) {
                return next(err);
              }
              return do_src();
            });
          });
        };
        do_src = function() {
          if (!answers.coffeescript) {
            return do_test();
          }
          return fs.mkdir("" + answers.location + "/src", function(err) {
            return fs.writeFile("" + answers.location + "/src/index.coffee", "\nmodule.exports = (callback) ->\n  process.setImmediate ->\n    callback null, 'Hello world'\n", function(err) {
              if (err) {
                return next(err);
              }
              return do_test();
            });
          });
        };
        do_test = function() {
          return fs.mkdir("" + answers.location + "/test", function(err) {
            var env;
            env = answers.name.toUpperCase().replace('-', '_');
            env = "" + env + "_COV";
            if (answers.coffeescript) {
              fs.writeFile("" + answers.location + "/test/index.coffee", "should = require 'should'\nindex = if process.env['" + env + "'] then require '../lib-cov' else require '../lib'\n\ndescribe '" + answers.name + "', ->\n\n  it 'pass hello world', (next) ->\n    index (err, value) ->\n      return next err if err\n      value.should.eql 'Hello world'\n      next()", function(err) {});
            } else {
              fs.writeFile("" + answers.location + "/test/index.js", "var should = require('should');\nvar index = process.env['" + env + "'] ? require('../lib-cov') : require('../lib');\n\ndescribe('" + answers.name + "', function() {\n  return it('pass hello world', function(next) {\n    return index(function(err, value) {\n      if (err) {\n        return next(err);\n      }\n      value.should.eql('Hello world');\n      return next();\n    });\n  });\n});", function(err) {});
            }
            return do_packagedotjson();
          });
        };
        return do_lib();
      };
      do_packagedotjson = function() {
        var content, dep, dependencies, dest, devDependencies, match, optional_dependencies, project, username, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
        dest = "" + answers.location + "/package.json";
        content = {};
        content.name = answers.name;
        if (answers.github) {
          if (match = /\w+@github.com:(.*)\/(.*)\.git/) {
            username = match[1];
            project = match[2];
          } else if (match = /\w+:\/\/github.com\/(.*)\/(.*)\.git/) {
            username = match[1];
            project = match[2];
          }
          content.repository = {
            type: 'git',
            url: answers.github
          };
        }
        content.dependencies = {};
        dependencies = answers.dependencies;
        if (dependencies !== '') {
          _ref = answers.dependencies.split(',');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            dep = _ref[_i];
            content.dependencies[dep] = 'latest';
          }
        }
        content.devDependencies = {};
        devDependencies = answers.devDependencies;
        if (devDependencies !== '') {
          _ref1 = answers.devDependencies.split(',');
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            dep = _ref1[_j];
            content.devDependencies[dep] = 'latest';
          }
        }
        content.optionalDependencies = {};
        optional_dependencies = answers.optionalDependencies;
        if (optional_dependencies !== '') {
          _ref2 = answers.optionalDependencies.split(',');
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            dep = _ref2[_k];
            content.optionalDependencies[dep] = 'latest';
          }
        }
        content = JSON.stringify(content, null, 4);
        return fs.writeFile(dest, content, 'utf8', function(err) {
          if (err) {
            return error(err, true);
          }
          return do_makefile();
        });
      };
      do_makefile = function() {
        var compilers, content;
        content = [];
        if (answers.coffeescript) {
          content.push("build:\n  @./node_modules/.bin/coffee -b -o lib src/*.coffee");
        }
        if (answers.test_tool === 'mocha') {
          compilers = answers.coffeescript ? '--compilers coffee:coffee-script ' : '';
          content.push("test: build\n  @NODE_ENV=test ./node_modules/.bin/mocha " + compilers + "\n    --reporter dot");
        }
        if (answers.coverage_tool === 'istanbul') {
          content.push("coverage: build\n  @istanbul cover _mocha -- -R spec --compilers coffee:coffee-script");
        }
        if (answers.test_tool) {
          content.push(".PHONY: test");
        }
        if (!content.length) {
          return do_finish();
        }
        return fs.writeFile("" + answers.location + "/Makefile", content.join('\n\n'), 'utf8', function(err) {
          if (err) {
            return next(err);
          }
          return do_finish();
        });
      };
      do_finish = function() {
        return _this.quit();
      };
      return do_check();
    };
  };
  this.load = function() {
    var ask, enoent, read;
    ask = function() {
      return options["interface"].question('Where is the project file? ', function(answer) {
        answer = answer.trim();
        if (answer === '') {
          return ask();
        }
        return read(answer);
      });
    };
    read = function(src) {
      return fs.readFile(src, function(err, content) {
        var old_options;
        if (err && err.code === 'ENOENT') {
          return enoent();
        }
        if (err) {
          return _this.error(err);
        }
        old_options = options;
        options = JSON.parse(content);
        for (k in old_options) {
          v = old_options[k];
          if (options[k] == null) {
            options[k] = v;
          }
        }
        _this.questions = null;
        return _this.intro();
      });
    };
    enoent = function() {
      options["interface"].write("" + options.enoent + "\n");
      return ask();
    };
    return ask();
  };
  this.reset = function() {
    var question, _i, _len, _ref;
    _ref = options.questions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      question = _ref[_i];
      delete question.value;
    }
    options.index = 0;
    return _this.create();
  };
  this.error = function(err) {
    process.stderr.write("Sorry, an unexpected error occured.\nPlease fill a bug report https://github.com/wdavidw/node-csv-parser/issues.\nAbout to exit.\n");
    return _this.emit('error', err);
  };
  this.save = function() {
    var where, write;
    where = function() {
      return options["interface"].question(options.save_where, function(answer) {
        return save(answer);
      });
    };
    write = function(dest) {
      var content;
      content = JSON.stringify(options);
      return fs.writeFile(dest, content, function(err) {
        return options["interface"].write("" + options.save_successfull + ".\n");
      });
    };
    return _this.view();
  };
  process.nextTick(function() {
    if (options.intro) {
      return _this.intro();
    } else {
      return _this[options.action]();
    }
  });
  return this;
};

util.inherits(mkpkg, EventEmitter);

module.exports = function(options) {
  return new mkpkg(options);
};
